import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 6 - Param√®tres et fonctions

:::note R√©sum√© de la s√©ance

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Param√®tres de scripts
1. Fonctions
1. Validations de param√®tres

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

- Exercice 05a - Param√®tres d'un script
- Exercice 05b - Fonctions
- Exercice 05c - Validation de param√®tres

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::


## Les scripts et le pipeline

Lorsqu‚Äôil est d√©marr√© dans une session PowerShell, un fichier de script (.ps1) se comporte exactement comme une commande:
- Il retourne des objets sur le pipeline
- Il admet des objets en entr√©e du pipeline
- Il permet de sp√©cifier des arguments

Par exemple, voici un script `MonScript.ps1` situ√© dans le r√©pertoire `C:\Scripts`. 

```powershell
$reponse = Read-Host -Prompt "Entrez le nom d'un service"
$reponse | Get-Service   # Renvoie le service dans le pipeline
```

√Ä la fin de l'ex√©cution du script, un ou des objets sont envoy√©s sur le pipeline, r√©sultat de `Get-Service`. Ces objets sortent donc du script comme s'il s'agissait d'une commande. Si on ne fait rien avec, les objets sont convertis en texte et affich√©s dans la console, mais on peut les intercepter en cha√Ænant une autre commande dans le pipeline.

![image](./assets/r06_01a.png)


## Param√®tres d'un script

Un script peut admettre un ou plusieurs param√®tres pour modifier son fonctionnement. On peut d√©clarer les param√®tres dans un bloc `param()`, qui doit se trouver obligatoirement **au tout d√©but** du script.

```powershell
param (
    [double] $Param1,
    [string] $Param2,
    [int[]]  $Param3,
    [switch] $Param4
)
```

On y d√©clare les param√®tres sous forme de variables typ√©es. Le nom de la variable repr√©sente le nom du param√®tre, et l'ordre de d√©claration des param√®tres devient sa position (lorsqu'on ne sp√©cifie pas son nom √† l'appel).

Lorsque le script sera appel√©, les arguments sp√©cifi√©s meubleront les variables qui leur sont associ√©es, et on pourra les utiliser dans le script.

Par exemple, ce script, `division.ps1` prend en param√®tre deux nombres, un dividende et un diviseur, effectue la division de ces deux nombres, et jette le r√©sultat dans le pipeline.

```powershell
param (
    [double]$Dividende,
    [double]$Diviseur
)

$Dividende / $Diviseur
```

![image](./assets/r06_01b.png)

On remarquera aussi que PowerShell est conscient des param√®tres d√©clar√©s dans le script car il nous permet de les compl√©ter avec la touche de tabulation ou avec `Ctrl+Espace`.

![image](./assets/r06_01c.png)


## Fonctions

Une fonction PowerShell est un bloc de script qu'on enregistre dans la session en cours. On doit la d√©clarer en lui donnant un nom, et √† l'instar d'un fichier de script, elle se comporte exactement comme un script ou une commande.

Pour d√©clarer une fonction, on utilise le mot-cl√© `function` suivi de son nom, et on d√©finit le code de la fonction entre des accolades. Il est recommand√© d'indenter le contenu de la fonction.

```powershell
function Get-Zero {
    0
}
```

:::caution
La d√©claration d'une fonction n'a d'effet que dans la session en cours. Apr√®s l'ex√©cution du script ou apr√®s fermeture de la fen√™tre PowerShell, celle-ci n'existe plus et il faudra la d√©clarer √† nouveau si on veut l'utiliser.
:::

:::tip
On peut obtenir la liste de toutes les fonctions qui sont d√©clar√©es dans la session PowerShell en cours √† l'aide de la commande `Get-ChildItem Function:`.

![image](./assets/r06_01g.png)
:::

L'exemple ci-dessus montre la fonction d√©clar√©e sous le nom de `Get-Zero`, et qui sert simplement √† obtenir la valeur 0. Celle-ci ne fait qu'envoyer l'objet `0` (un nombre entier) dans le pipeline, afin que cette valeur soit r√©cup√©r√©e √† la sortie de la fonction.

![image](./assets/r06_01f.png)


### Sortie dans le pipeline

Une fonction (tout comme un script, d'ailleurs), dispose en quelque sorte d'un "accumulateur" qui contient tous les objets qui tombent dans le pipeline. √Ä la sortie de la fonction, les objets sortent sous forme de collection.

```
function Get-CrisDAnimaux {
    "Miaou!"
    "Wouf!"
    "Cocorico!"
}
```

Cette fonction laisse tomber trois objets `String` dans le pipeline. Ceux-ci sortent sous forme de collection. C'est la m√™me chose avec un fichier PS1.

![image](./assets/r06_01h.png)


### Instruction *Return*

L'instruction `return` permet de sortir un objet sur le pipeline tout en interrompant imm√©diatement l'ex√©cution de la fonction. 

```powershell
function Get-Zero {
    return 0
    Write-Host "Ce texte ne sera jamais √©crit!"
}
```

:::info
Dans un script, on utilise souvent une fonction lorsque du code se r√©p√®te souvent, pour √©viter de copier-coller le m√™me code √† plusieurs endroits dans le script. Une fonction doit obligatoirement √™tre d√©finie avant d'√™tre appel√©e, mais il est une bonne pratique de d√©clarer toutes les fonctions au d√©but du script, juste apr√®s le bloc de param√®tres, mais avant le code principal du script.
:::


## Validation des param√®tres

Une fonction et un script `.PS1` se comportent comme une commande PowerShell. L'un est enregistr√© dans la session en cours, l'autre est d√©fini sous forme de fichier. Mais dans les deux cas, on peut leur d√©finir des param√®tres au moyen d'un bloc `param()`.

Par exemple, le script `Division.ps1` vu pr√©c√©demment aurait pu, √† la place, √™tre d√©fini comme une fonction.

```powershell
function Division {
    param (
        [double] $Dividende,
        [double] $Diviseur
    )

    $Dividende / $Diviseur
}
```

Lorsqu'on d√©clare des param√®tres, il y a le risque que celui-ci soit mal utilis√©. Par exemple, qu'arrive-t-il si on appelle la fonction de division pour diviser "Chat" par trois? Qu'arrive-t-il si on demande de diviser un nombre par z√©ro?

Et surtout, qu'arrive-t-il si, dans un script assez long et qui effectue plusieurs t√¢ches, un param√®tre non conforme fait planter le script √† mi-chemin de son ex√©cution?

PowerShell nous offre diverses m√©thodes pour valider les param√®tres √† la source, afin de s'assurer que toutes les valeurs sont conformes √† ce qui est attendu avant de commencer son ex√©cution.


### Validation de type

Lorsqu'on sp√©cifie un type √† un param√®tre, le script valide d'abord si la valeur correspond au type attendu.

```powershell
param (
    [double] $Dividende,
    [double] $Diviseur
)

$Dividende / $Diviseur
```

Si la valeur attendue ne correspond pas au type du param√®tre, le script plante (et c'est ce qu'on veut; mieux vaut un script qui plante qu'un script qui fait n'importe quoi).

![image](./assets/r06_01i.png)


### Crit√®res de validation

PowerShell offre, en plus de la validation de type, diff√©rents crit√®res de validation pour identifier au maximum les risques de valeurs ill√©gales sp√©cifi√©es en param√®tre.

Par exemple, si on souhaite √©viter que la fonction ou le script puisse √™tre appel√© avec un diviseur √©gal √† z√©ro, on peut ajouter un crit√®re de validation dans la d√©claration du param√®tre. Dans l'exemple suivant, on d√©finit un script qui, s'il est √©valu√© `False`, refusera d'ex√©cuter le code.

```powershell
param (
    [double] $Dividende,

    [ValidateScript( { $_ -ne 0 } )]
    [double] $Diviseur
)

$Dividende / $Diviseur
```

On peut clairement voir, √† l'analyse du message d'erreur, que le script ou la fonction a plant√© en raison d'un √©chec de validation du param√®tre `Diviseur`.

![image](./assets/r06_01j.png)

Il existe plusieurs types de validation de param√®tre. En voici quelques exemples:

#### ValidateSet

La clause `ValidateSet` permet de s'assurer que la valeur pass√©e en param√®tre fait partie d'une liste de valeurs admissibles.

```powershell
param( 
    [ValidateSet('Rouge','Vert','Bleu‚Äô)]
    [string] $Couleur 
)

# Accepte seulement les cha√Ænes de caract√®res "Rouge", "Vert" ou "Bleu"
```

:::tip
Lorsqu'on utilise la clause `ValidateSet`, cela permet √† PowerShell d'√©num√©rer les valeurs admissibles lors de l'appel de la fonction ou du script, au moyen de la touche de tabulation ou de `Ctrl+Espace`.

![image](./assets/r06_01k.png)
:::

#### ValidateRange

La clause `ValidateRange` permet de s'assurer qu'un nombre pass√© en param√®tre est situ√© entre deux valeurs inclusivement.

```powershell
param(
    [ValidateRange(7,120)]
    [Int] $Age
)

# Accepte un nombre entier de 7 √† 120 incl.
```

:::tip
`ValidateRange` exige de sp√©cifier les valeurs minimum et maximum. Mais lorsqu'on souhaite seulement sp√©cifier une valeur maximum ou minimum, on peut faire appel aux propri√©t√©s MaxValue et MinValue du type en question.

Par exemple, pour attendre un nombre de type `[int]` de 7 ou plus, il suffit de sp√©cifier un *range* de 7 √† la valeur maximale du type `[int]`, soit `[int]::MaxValue`.

```powershell
param(
    [ValidateRange(7, [int]::MaxValue)]
    [Int] $Age
)

# Accepte un nombre entier de 7 ou plus.
```
:::


#### ValidateLength

La clause `ValidateLength` valide la taille minimum et maximum d'une cha√Æne de caract√®res.

```powershell
param(
    [ValidateLength(0,15)]
    [String] $NoTel
)

# Accepte une cha√Æne de 0 √† 15 caract√®res incl.
```


#### ValidateCount

La clause `ValidateCount` valide le nombre d'√©l√©ments minimum et maximum d'une collection d'objets pass√©e en param√®tre.

```powershell
param(
    [ValidateCount(1,5)]
    [String[]] $ComputerName
)

# Accepte un tableau de 1 √† 5 √©l√©ments incl.
```

#### ValidateScript

La clause `ValidateScript` est la plus versatile et peut √™tre utilis√©e pour les validations plus complexes qui ne peuvent √™tre faites par les autres m√©thodes. Elle permet de sp√©cifier un script √† ex√©cuter avec la valeur pass√©e en param√®tre (repr√©sent√©e par la variable pipeline `$_`). Si le script retourne `True`, l'argument est valid√©; s'il retourne `False`, la validation √©choue et le script plante.

```powershell
param(
    [ValidateScript( { Test-Path $_ } )]
    [String] $Path
)

# Permet de cr√©er un script qui retourne vrai ou faux. Si faux, le param√®tre est rejet√©.
```

### Param√®tres obligatoires

Par d√©faut, tous les param√®tres sont optionnels. S'ils ne sont pas sp√©cifi√©s lors de l'appel de la fonction ou du script, alors ils prennent automatiquement leur valeur neutre.

- La valeur 0 pour les types num√©riques (`int`, `double`...)
- Une cha√Æne vide (`""`) pour le type `string`
- Une valeur nulle (`$null`) pour les collections
- etc.

Pour s'assurer qu'un param√®tre soit sp√©cifi√© √† l'appel de la fonction ou du script, on peut ajouter un bloc `[Parameter()]` √† la d√©claration du param√®tre. Ce bloc permet de d√©finir certaines propri√©t√©s du param√®tre. Pour rendre le param√®tre obligatoire, il faut activer la propri√©t√© Mandatory du param√®tre.

```powershell
function Soustraction {
    param(
        [Parameter(Mandatory)]
        [double] $op1,

        [Parameter(Mandatory)]
        [double] $op2
    )

    $op1 - $op2
}
```

Si un param√®tre obligatoire n'est pas sp√©cifi√©, le script refusera de s'ex√©cuter. √Ä la place, il demandera √† l'utilisateur de sp√©cifier les param√®tres manquants √† la ligne de commande. L'appelant peut alors soit saisir manuellement l'argument manquant, soit annuler l'ex√©cution du script avec les touches `Ctrl+C`.

![image](./assets/r06_01l.png)


### Valeur par d√©faut d'un param√®tre

Une alternative √† rendre obligatoire un param√®tre consiste √† lui attribuer une valeur par d√©faut. Ainsi, ce param√®tre prendra automatiquement la valeur sp√©cifi√©e si l'utilisateur ne le sp√©cifie pas √† l'appel du script ou de la fonction.

Par exemple, voici le script `Arrondir.ps1`.

```powershell
Param(
    [Parameter(Mandatory)]
    [double] $Nombre,

    [int] $Decimales = 2
)

[Math]::Round($Nombre, $Decimales)
```

La valeur du param√®tre `Decimales` prend la valeur 2 √† moins d'√™tre sp√©cifi√©e explicitement.

![image](./assets/r06_01m.png)


### Param√®tres de type Switch

Les param√®tres de type Switch prennent une valeur bool√©enne (vraie ou fausse) selon qu'ils soient sp√©cifi√©s ou non. On les identifie avec le type [switch].

```powershell
param (
    [Parameter(Mandatory)]
    [double] $op1,
    
    [Parameter(Mandatory)]
    [double] $op2,
    
    [switch] $Miauler
)

$op1 - $op2

if ($Miauler) {
    Write-Host "Miaou!"
}
```

### Param√®tres de type collection

Il est possible de faire en sorte qu'un param√®tre admette plus d'une valeur. Il suffit de faire de son type une collection. Si par exemple, on souhaite que le param√®tre permette de passer une ou plusieurs valeurs enti√®res, on va donner au param√®tre le type `[int[]]`, soit un tableau d'entier.

```powershell
param ( 
    [int[]] $Nombres 
)

$total = 0

foreach ($nombre in $Nombres) {
    $total += $nombre
}

# On renvoie le total dans le pipeline!
$total    
```

:::tip
Les param√®tres qui admettent un tableau de valeurs se combinent tr√®s bien avec la clause de validation `[ValidateCount()]`, pour sp√©cifier un nombre minimum et maximum d'√©l√©ments dans le tableau.
:::


### Entr√©e par le pipeline

On peut permettre √† une fonction ou un script de traiter l'entr√©e du pipeline.

Par exemple, le script Saluer.ps1 accepte deux param√®tres, un nom et un titre. Mais lorsqu'une valeur admissible entre par le pipeline, celle-ci entrera dans le param√®tre Nom.

```powershell
Param(
    [Parameter(Mandatory, ValueFromPipeline)]
    [string] $Nom,

    [ValidateSet("M.","Mme.","Mlle.","Dr.","Me.")]
    [string] $Titre
)

"Bonjour, $Titre $Nom!"
```

De cette mani√®re, le param√®tre Nom peut soit √™tre sp√©cifi√© par le param√®tre, soit par l'entr√©e du pipeline. Dans les deux cas, l'effet est le m√™me.

![image](./assets/r06_01n.png)


