import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Rencontre 3 - Collections et types

:::note R√©sum√© de la s√©ance

<Tabs>

<TabItem value="deroulement" label="üë®‚Äçüè´ D√©roulement du cours">

1. Rappel du cours pr√©c√©dent
1. Variables et types de donn√©es
1. Collections et tableaux

</TabItem>

<TabItem value="exercices" label="üíª Exercices √† compl√©ter">

Les exercices suivants se trouvent dans votre section personnelle du bloc-notes du cours, sous l'onglet _Exercices_:

- Exercice 03: Collections

</TabItem>

<TabItem value="ressources" label="üìö Ressources √† consulter">

La pr√©sentation PowerPoint est sur le Teams du cours, sous le canal G√©n√©ral > Fichiers > Supports de cours.

</TabItem>

</Tabs>

:::

## Types de donn√©es

Tout objet en PowerShell poss√®de un type, et s'il est dans une variable, celle-ci poss√®de √©galement ce type. Il existe plusieurs types distincts.

### Nombres entiers

| Type                    | Description                 | Valeur minimale            | Valeur maximale            |
| ----------------------- | --------------------------- | -------------------------- | -------------------------- |
| `[byte]`                | Entier non sign√© de 8 bits  | 0                          | 255                        |
| `[sbyte]`               | Entier sign√© de 8 bits      | -128                       | 127                        |
| `[int16]`               | Entier sign√© de 16 bits     | -32 768                    | 32 767                     |
| `[uint16]`              | Entier non sign√© de 16 bits | 0                          | 65 535                     |
| `[int32]` _ou_ `[int]`  | Entier sign√© de 32 bits     | -2 147 483 648             | 2 147 483 647              |
| `[uint32]`              | Entier non sign√© de 32 bits | 0                          | 4 294 967 295              |
| `[int64]` _ou_ `[long]` | Entier sign√© de 64 bits     | -9 223 372 036 854 775 808 | 9 223 372 036 854 775 807  |
| `[uint64]`              | Entier non sign√© de 64 bits | 0                          | 18 446 744 073 709 551 615 |

:::info
Par d√©faut, les nombres entiers sont de type `[int32]` (ou `[int64]` s'il sont trop grands). Pour qu'ils soient de type diff√©rent, il faut le sp√©cifier devant la valeur. (Par exemple, `[uint32]42`).
:::

### Nombre √† virgule flottante (d√©cimaux)

| Type                      | Description                                                 | Pr√©cision | Valeur minimale/maximale                 |
| ------------------------- | ----------------------------------------------------------- | --------- | ---------------------------------------- |
| `[single]` _ou_ `[float]` | Nombre √† virgule flottante de pr√©cision simple              | 32 bits   | ¬± 3,402 823 E+38                         |
| `[double]`                | Nombre √† virgule flottante de pr√©cision double (par d√©faut) | 64 bits   | ¬± 1,79 769 313 486 232 E+308             |
| `[decimal]`               | Nombre d√©cimal                                              | 128 bits  | ¬± 79 228 162 514 264 337 593 543 950 335 |

:::info
Par d√©faut, les nombres non entiers sont de type `[double]`. Pour qu'ils soient d'un autre type, il faut le sp√©cifier devant la valeur (par exemple, `[single] 3.14`).

Les nombres √† virgule flottante sont la m√©thode qu'emploient les ordinateurs pour repr√©senter les nombres non entiers. Ils combinent une mantisse et un exposant, comme dans la notation scientifique, ce qui permet de repr√©senter de tr√®s grands nombres mais en sacrifiant de la pr√©cision. Vous pouvez suivre ce lien pour en apprendre davantage sur la virgule flottante en informatique.
:::

### Autres types de donn√©es

| Type                      | Description                                                                      | Example                                                    |
| ------------------------- | -------------------------------------------------------------------------------- | ---------------------------------------------------------- |
| `[boolean]` _ou_ `[bool]` | Valeur bool√©enne (`$true` ou `$false`)                                           | `$true`                                                    |
| `[string]`                | Cha√Æne de caract√®res √† taille fixe                                               | `"allo"`                                                   |
| `[char]`                  | Caract√®re unicode de 16 bits                                                     | `[char]"X"`                                                |
| `[datetime]`              | Date et heure                                                                    | `Get-Date`                                                 |
| `[hashtable]`             | Table de hachage                                                                 | `@{a = 1; b = 2; c = 3}`                                   |
| `[pscustomobject]`        | Objet dictionnaire                                                               | `[pscustomobject]@{a = 1; b = 2; c = 3}`                   |
| `[object]`                | Type qui d√©crit n'importe quel objet (toutes les classes d√©rivent de `[object]`) |                                                            |
| `[array]` _ou_ `[type[]]` | Tableau (contient plusieurs objets, dans un ordre pr√©cis)                        | `@(1, 2, 3)`                                               |
| `[scriptblock]`           | Bloc de script pr√©compil√©                                                        | `$script = [scriptblock]{ # une ou plusieurs commandes‚Ä¶ }` |
| `[math]`                  | Expose des fonctions math√©matiques                                               | `[math]::Pow(10,2)`                                        |

Pour en savoir plus sur les types de donn√©es PowerShell, consultez [cette page](https://learn.microsoft.com/fr-fr/powershell/scripting/lang-spec/chapter-04?view=powershell-5.1).

### Valeurs minimum et maximum

Toute donn√©e est un objet, et un objet poss√®de un type. Dans le paradigme orient√© objet, un type est une classe, et un objet de ce type est une instance de cette classe. Les classes sont en quelque sorte des plans, ou mod√®les, qui dictent √† quoi une donn√©e doit ressembler. Une classe est repr√©sent√©e entre crochets `[` et `]`.

La classe elle-m√™me expose des m√©thodes et des attributs, dits statiques, qui d√©crivent certains aspects de ce type. Alors qu'on peut acc√©der aux m√©thodes et attributs d'un objet (ou instance de classe) avec un point `.` , on acc√®de les m√©thodes et attributs d'une classe avec un double deux points `::`.

Dans le cas des types num√©riques, des attributs de la classe correspondant au type nous permettent d'obtenir les valeurs minimum et maximum que ce type supporte.

![image](./assets/r03_01a.png)

### Conversion de types

On peut convertir les valeurs d'un type √† l'autre, et les castant, c‚Äôest-√†-dire en for√ßant le type.

![image](./assets/r03_01b.png)

Il faut toutefois faire attention que la valeur soit compatible avec le type vers lequel on souhaite la convertir.

![image](./assets/r03_01c.png)

### Suffixes de multiplication des octets

PowerShell nous offre un moyen de calculer facilement les grandeurs (Ko, Mo, Go, etc.)

| Suffixe | Signification | Valeur                                                    |
| ------- | ------------- | --------------------------------------------------------- |
| Kb      | Kibioctet     | 2<sup>10</sup> = 1024                                     |
| Mb      | M√©bioctet     | 2<sup>20</sup> = 1024<sup>2</sup> = 1 048 576             |
| Gb      | Gibioctet     | 2<sup>30</sup> = 1024<sup>3</sup> = 1 073 741 824         |
| Tb      | T√©bioctet     | 2<sup>40</sup> = 1024<sup>4</sup> = 1 099 511 627 776     |
| Pb      | P√©bioctet     | 2<sup>50</sup> = 1024<sup>5</sup> = 1 125 899 906 842 624 |

Cela peut s'av√©rer tr√®s pratique pour, par exemple, calculer les tailles de fichiers.

![image](./assets/r03_01d.png)

### Cha√Ænes de caract√®res

Les cha√Ænes de caract√®res sont un type de donn√©es particuli√®rement commun dans tous les langages de programmation, et PowerShell ne fait pas exception.

#### Guillemets

En PowerShell, les cha√Ænes de caract√®res sont balis√©es par des guillemets. Les guillemets simples et doubles sont accept√©s.

![image](./assets/r03_02a.png)

Un type de guillemet compris dans une cha√Æne balis√©e par l'autre type de guillemets sera affich√© tel quel.

![image](./assets/r03_02b.png)

Par contre, les deux types de guillemets se comportent diff√©remment avec les variables. Le variables √©crites dans une cha√Æne √† guillemets doubles sont r√©solues, alors que celles dans une cha√Æne √† guillemets simples ne le sont pas.

![image](./assets/r03_02c.png)

Pour √©crire √† la fois des guillemets doubles dans une cha√Æne et r√©soudre une variable, on peut soit doubler les guillemets doubles (un double-double-guillemet repr√©sente le caract√®re du double-guillemet), ou encore mettre un caract√®re d'√©chappement (le backtick) juste avant pour le forcer √† √™tre repr√©sent√© comme caract√®re dans la cha√Æne.

![image](./assets/r03_02d.png)

Pour les cas plus complexes, on peut construire une variable temporaire au sein d'une cha√Æne de caract√®res, avec la formule $(). C'est pratique si on veut non pas r√©soudre une variable dans une cha√Æne, mais plut√¥t r√©soudre une expression.

![image](./assets/r03_02e.png)

De cette mani√®re, on peut r√©soudre n'importe quelle expression au sein de la cha√Æne de caract√®res.

![image](./assets/r03_02f.png)

#### Concat√©nation

On peut aussi concat√©ner deux cha√Ænes de caract√®res avec l'op√©rateur de concat√©nation `+`.

![image](./assets/r03_02g.png)

Une autre option pour unir plusieurs √©l√©ments d'une cha√Æne est d'utiliser l'op√©rateur de formatage `-f`. On √©crit la cha√Æne de caract√®res mais en y ins√©rant des jetons \{n\}. Ceux-ci seront remplac√©s par le contenu des variables sp√©cifi√©es apr√®s l'op√©rateur `-f`.

![image](./assets/r03_02h.png)

Ou encore, on peut toujours ins√©rer les variables directement dans la cha√Æne, lorsqu'on utilise des guillemets doubles.

![image](./assets/r03_02i.png)

### Op√©rateurs

#### Op√©rateurs arithm√©tiques

| Op√©rateur | Description    |
| --------- | -------------- |
| `+`       | Addition       |
| `-`       | Soustraction   |
| `*`       | Multiplication |
| `/`       | Division       |
| `%`       | Modulo         |

![image](./assets/r03_03a.png)

L'op√©rateur modulo sert √† donner le reste de la division enti√®re. En PowerShell, c'est le caract√®re `%` qui d√©signe cet op√©rateur. Pour la division enti√®re par contre, PowerShell n'offre pas d'op√©rateur, √† la diff√©rence de plusieurs autres langages. L'op√©rateur `/` produit une valeur de type `[double]` si le r√©sultat n'est pas un nombre entier, et caster le r√©sultat √† `[int]` arrondit ce r√©sultat √† l'entier le plus proche. Par cons√©quent, la composante enti√®re de la division peut √™tre obtenue en appelant la fonction plancher de la classe utilitaire Math.

![image](./assets/r03_03b.png)

#### Op√©rateurs de comparaison

Les op√©rateurs de comparaison retournent une valeur bool√©enne vraie ou fausse dans le pipeline, selon un crit√®re pr√©cis. On les utilise entre deux valeurs.

| Op√©rateur       | Description               | Exemple                                       |
| --------------- | ------------------------- | --------------------------------------------- |
| `-eq`           | √âgal √†                    | `0 -eq 0`                                     |
| `-ne`           | Pas √©gal √†                | `0 -ne "allo"`                                |
| `-gt`           | Plus grand que            | `1 -gt 0`                                     |
| `-ge`           | Plus grand ou √©gal √†      | `0 -ge 0`                                     |
| `-lt`           | Plus petit que            | `-1 -lt 0`                                    |
| `-le`           | Plus petit ou √©gal √†      | `0 -le 0`                                     |
| `-like`         | Comparaison avec wildcard | `"allo" -like "a*"`                           |
| `-notlike`      | Inverse de `-like`        | `"bonjour" -notlike "a*"`                     |
| `-match`        | Comparaison regex         | `"514-555-0123" -match "\d{3}-\d{3}-\d{4}"`   |
| `-nomatch`      | Inverse de `-match`       | `"(514) 555-0123" -match "\d{3}-\d{3}-\d{4}"` |
| `-is`           | Comparaison de type       | `1.1 -is [double]`                            |
| `-isnot`        | Inverse de `-is`          | `1 -isnot [double]`                           |
| `-and`          | Et logique                | `(0 -eq 0) -and ("pomme" -eq "pomme")`        |
| `-or`           | Ou logique                | `(0 -eq 0) -or ("pomme" -eq "banane")`        |
| `-not` _ou_ `!` | Non logique               | `-not (1 -eq 0)` <br/> `!(1 -eq 0)`           |
| `-xor`          | Ou exclusif               | `$true -xor $false`                           |

![image](./assets/r03_03c.png)

#### Op√©rateurs d'affectation

Les op√©rateurs d'affectation modifient l'op√©rande de gauche.

| Op√©rateur Description | Exemple                          | √âquivalent |
| --------------------- | -------------------------------- | ---------- | ------------- |
| `=`                   | Affectation simple               | `$i = 2`   |               |
| `+=`                  | Affectation apr√®s addition       | `$i += 2`  | `$i = $i + 2` |
| `-=`                  | Affectation apr√®s soustraction   | `$i -= 2`  | `$i = $i - 2` |
| `*=`                  | Affectation apr√®s multiplication | `$i *= 2`  | `$i = $i * 2` |
| `/=`                  | Affectation apr√®s division       | `$i /= 2`  | `$i = $i / 2` |
| `%=`                  | Affectation apr√®s modulo         | `$i %= 2`  | `$i = $i % 2` |
| `++`                  | Incr√©mentation                   | `$i++`     | `$i = $i + 1` |
| `--`                  | D√©cr√©mentation                   | `$i--`     | `$i = $i - 1` |

## Collections et tableaux

Les commandes PowerShell retournent souvent non pas un objet, mais plusieurs objets dans le pipeline. Par exemple, il est fr√©quent que la commande `Get-ChildItem` retourne plus d'un objet, car il y a g√©n√©ralement plusieurs fichiers et dossiers dans un dossier.

![image](./assets/r03_04a.png)

### Compter les objets d'une collection

On peut conna√Ætre le nombre d'√©l√©ments retourn√©s par une commande √† l'aide de la commande `Measure-Object`.

![image](./assets/r03_04b.png)

Et comme plusieurs objets mis ensemble constituent une collection d'objets, et que cette collection est √©galement un objet, on peut aussi lire l'attribut `.Length` de cette collection.

![image](./assets/r03_04c.png)

### Acc√©der √† un √©l√©ment pr√©cis

Une collection dans PowerShell est une liste d'objet, qu'on appelle aussi Tableau ou Array, et qui est compos√© de plusieurs valeurs dans un ordre pr√©cis. Chaque √©l√©ment occupe une position: le premier a la position 0, le deuxi√®me 1, et ainsi de suite. Ces nombre s'appelle un indice (index). On peut obtenir l'√©l√©ment correspondant en sp√©cifiant l'indice voulu entre crochets.

![image](./assets/r03_04d.png)

### Cr√©er un tableau

Un tableau vide est cr√©√© avec la formule `@()`. Pour initialiser un nouveau tableau, donc, il suffit d'affecter le tableau vide √† une variable. On peut ensuit lui ajouter des √©l√©ments, avec un op√©rateur d'affectation.

![image](./assets/r03_05a.png)

Un tableau peut comprendre plusieurs √©l√©ments de types diff√©rents, mais habituellement, on il est plus logique d'y retrouver des √©l√©ments du m√™me type.

On peut affecter directement des valeurs √† la cr√©ation d'un tableau. Dans ce cas, on n'est pas oblig√© de respecter la syntaxe `@(‚Ä¶)`; elle est implicite.

![image](./assets/r03_05b.png)

On peut aussi utiliser un raccourci pour cr√©er rapidement un tableau d'entiers.

![image](./assets/r03_05c.png)

### S√©lectionner des √©l√©ments

Lorsqu'on a un tableau d'objet qui circule dans le pipeline, on peut vouloir manipuler ce tableau pour en ressortir certains √©l√©ments et pas d'autres.

#### S√©lection des indices

![image](./assets/r03_06a.png)

#### S√©lection conditionnelle

![image](./assets/r03_06b.png)

Ou‚Ä¶

![image](./assets/r03_06c.png)

![image](./assets/r03_06d.png)

![image](./assets/r03_06e.png)

### Op√©rations sur un tableau

#### Op√©rateur -Contains

Pour tester si un tableau contient une valeur sp√©cifique, on peut utiliser l'op√©rateur `-Contains`.

![image](./assets/r03_07a.png)

#### Concat√©nation

Donne tous les objets des deux collections (fusionne deux collections bout √† bout)

![image](./assets/r03_07b.png)

#### Union

Donne tous les objets de deux collections, mais sans doublons.

![image](./assets/r03_07c.png)

#### Intersection

Donne tous les objets qui ont √† la fois dans deux collections

![image](./assets/r03_07d.png)

#### Diff√©rence

Retourne une collection moins tous les √©l√©ments semblables d'une deuxi√®me collection

![image](./assets/r03_07e.png)

#### Tri

On peut trier une collection √† l'aide de la commande `Sort-Object`, par ordre croissant ou d√©croissant.

![image](./assets/r03_07f.png)

Par d√©faut, le tri s'effectue sur le nom d'affichage, mais il est possible de sp√©cifier sur quelle propri√©t√© devra s'effectuer le tri.

![image](./assets/r03_07g.png)
